<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深度学习-25个基本概念</title>
    <link href="/2021/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-25%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/02/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-25%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<div><blockquote style="margin-top:10px;margin-bottom:10px;border-left-width:10px;color:rgb(62,62,62);font-family:arial, sans-serif;font-size:small;padding-top:2px;padding-right:6px;padding-bottom:2px;line-height:1.7;letter-spacing:1px;word-spacing:1px;"><p style="font-size:16px;margin-top:20px;margin-bottom:20px;line-height:1.7;">人工智能，深度学习，机器学习……不管你在从事什么工作，都需要了解这些概念。否则的话，三年之内你就会变成一只恐龙。&nbsp;<span style="text-align:right;">—— 马克·库班</span></p></blockquote><a id="more"></a><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">库班的这句话，乍听起来有些偏激，但是“话糙理不糙”，我们现在正处于一场由大数据和超算引发的改革洪流之中。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">首先，我们设想一下，如果一个人生活在20世纪早期却不知电为何物，是怎样一种体验。在过去的岁月里，他已经习惯于用特定的方法来解决相应的问题，霎时间周围所有的事物都发生了剧变。以前需要耗费大量人力物力的工作，现在只需要一个人和电就能完成了。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">而在现在的背景下，机器学习、深度学习就是新的“电力”。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">所以呢，如果你还不了解深度学习有多么强大，不妨就从这篇文章开始。在这篇文章中，作者Dishashree Gupta为想了解深度学习的人，罗列并解释了25个这一领域最常用的术语。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">这25个术语被分成三组：</p><ul><li>神经网络中的基础概念<span style="background-color:rgb(255,255,255);color:rgb(62,62,62);font-family:arial, sans-serif;font-size:16px;letter-spacing:1px;word-spacing:1px;">(包含常用的一些激活函数)</span><br></li><li>卷积神经网络<br></li><li>递归神经网络<br></li></ul><h1 style="margin-top:20px;margin-bottom:20px;padding-left:15px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);line-height:1.2;font-size:20px;border-left:6px solid rgb(0,153,127);letter-spacing:1px;word-spacing:1px;">基础概念：</h1><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(1) 神经元(Neuron)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">正如我们大脑中的基本组成单元，神经元是组成神经网络的基础结构。设想一下当接触到新的信息时，我们的身体会对其进行处理，最后产生一些特定的反应。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">相似地，在神经网络中，在收到输入的信号之后，神经元通过处理，然后把结果输出给其它的神经元或者直接作为最终的输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);text-align:center;margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;"><img style="width:auto;height:auto;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;visibility:visible;" src="https://img.imgdb.cn/item/602238dd3ffa7d37b3160449.jpg" ></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(2) 加权/权重(Weights)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">当输入信号进入到神经元后，会被乘以相应的权重因子。举例来说，假设一个神经元有两个输入信号，那么每个输入将会存在着一个与之相应的权重因子。在初始化网络的时候，这些权重会被随机设置，然后在训练模型的过程中再不断地发生更改。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在经过训练后的神经网络中，一个输入具有的权重因子越高，往往意味着它的重要性更高，对输出的影响越大。另一方面，当权重因子为0时意味着这个输入是无价值的。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">如下图所示，假设输入为a，相应的权重为W1。那么通过赋权节点后相应的输入应变为a*W1。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/6022423b3ffa7d37b31b3804.png"></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(3) 偏置/偏倚(Bias)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">除了权重之外，输入还需要经过另外一种线性处理，叫做偏置。通过把偏置b与加权后的输入信号a*W1直接相加，以此作为激活函数的输入信号。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(4) 激活函数</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">之前线性处理之后的输入信号通过激活函数进行非线性变换，从而得到输出信号。即最后输出的信号具有f(a*W1+b)的形式，其中f()为激活函数。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在下面的示意图中， 设X1…Xn等n个输入分别对应着权重因子Wk1…Wkn以及相应的偏置b1…bn。我们把输入Xi乘以对应的权重因子Wki再加上bi的结果称为u。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">u=∑w*x+b</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">这个激活函数f是作用在u上的，也就是说这个神经元最终的输出结果为yk = f(u)</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/6022428f3ffa7d37b31b6501.jpg" ></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">接下来我们讲一讲常用的一些激活函数：Sigmoid函数， 线性整流函数(ReLU) 和 softmax函数</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;"><strong style="color:rgb(0,153,127);">(a) Sigmoid函数</strong></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">作为最常用的激活函数之一，它的定义如下：</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/602242b83ffa7d37b31b7d5b.png"></p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/6022438a3ffa7d37b31bf117.png"></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);text-align:right;line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"><strong style="color:rgb(0,153,127);">△</strong>&nbsp;</h6><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">sigmoid函数为值域在0到1之间的光滑函数，当需要观察输入信号数值上微小的变化时，与阶梯函数相比，平滑函数(比如Sigmoid函数)的表现更好。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;"><strong style="color:rgb(0,153,127);">(b) 线性整流函数(ReLU-Rectified Linear Units)</strong></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">近来的神经网络倾向于使用ReLU替代掉sigmoid函数作为隐层的激活函数，它的定义如下：</p><pre>f(x) = max(x,0).</pre><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">当x大于0时，函数输出x，其余的情况输出为0。函数的图像是：</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/602243373ffa7d37b31bc19f.png" ></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);text-align:right;line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"><strong style="color:rgb(0,153,127);">△</strong>&nbsp;</h6><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">使用ReLU函数的好处是，对于所有大于0的输入，导数是恒定的，这能够加快训练网络的速度。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;"><strong style="color:rgb(0,153,127);">(c) softmax函数</strong></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">softmax激活函数通常应用在分类问题的输出层上。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">它与Sigmoid函数相似，唯一的不同是softmax函数输出结果是归一化的。sigmoid函数能够在双输出的时候奏效，但当面对多种类分类问题的时候，softmax函数可以方便地直接将各个分类出现的概率算出。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(5) 神经网络</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">神经网络是构成深度学习系统的框架。神经网络的任务是找到一个未知函数的近似表达方式，它是由彼此相连的神经元所组成，这些神经元会在训练网络的过程中根据误差来更改它们的权重和偏置。激活函数将非线性变化用线性变化的组合来表示，最终产生输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">关于神经网络最好的定义是由Matthew Mayo给出的：</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">神经网络是由大量彼此相连、概念化的人造神经元组成的，这些神经元彼此之间传递着数据，相应的权重也会随着神经网络的经历而进行调整。神经元们有着激活的阈值，当它们遇到相应的数据以及权重时会被激活，这些被激活的神经元组合起来导致了“学习”行为的产生。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(6) 输入层/输出层/隐藏层</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">从名字中就能看出，输入层代表接受输入数据的一层，基本上是网络的第一层；输出层是产生输出的一层，或者是网络的最后一层，而网络中间的处理层叫做隐藏层。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">这些隐藏层对输入的数据进行特定的处理，再将其输入到下一层。输入层和输出层是可见的，而中间层通常是被隐藏起来的。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224c753ffa7d37b3205ca6.jpg"></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);text-align:right;line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(7) 多层感知器(MLP-Multi Layer Perceptron)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">一个单一的神经元不能够完成复杂的任务，因此需要将它们堆叠起来工作进而产生有用的输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">最简单的神经网络包括一个输入层、一个隐藏层和一个输出层。每一层都由多个神经元组成，每一层的每个神经元都与下一层中的所有神经元相连。这样的网络可以被称为是<strong style="color:rgb(0,153,127);">全连接网络</strong>。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224cbf3ffa7d37b32082c5.jpg" ></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(8) 正向传播(forward propagation)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">正向传播是指信号从输入层经过隐藏层到输出层的传输过程。在正向传播中，信号是沿着单一方向进行传播，即输入层给隐藏层提供输入，进而最终产生相应的输出。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(9) 成本函数(cost function)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在神经网络的建造过程中，建造者们希望输出的结果能够尽可能地接近实际值，因此使用成本函数来描述网络的这种准确性。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">神经网络的目标是增加预测的准确性从而减少误差，即最小化成本函数。通常情况下，最优化的输出结果往往对应着成本函数的最小值。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">如果采用均方误差作为成本误差，即表示为C= 1/m ∑(y – a)2，其中m是训练过程中输入数据的个数，a是相应的预测值，y代表实际值。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">模型学习的过程就是围绕着最小化成本而进行的。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(10) 梯度下降(gradient descent)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">梯度下降是一种最小化成本函数的优化算法。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在梯度下降中，从起始点x开始，一次移动一点，比如说移动delta h，然后将位置信息更换为x-delta h，如此重复下去，直到达到局部的极小值，此时认为极小值就是成本最小的地方。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224cf23ffa7d37b3209e49.jpg" ></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">数学上说，沿着函数的负梯度运动就能得到函数的局域最小值。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(11) 学习速率(learning rate)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">学习速率定义为在每次迭代过程中对成本函数的最小化次数。简单来说，学习速率就是指朝着成本函数最小值的下降速率。选择学习速率需要很谨慎，过大会导致可能越过最优解，过小会导致收敛花费太多的时间。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224d103ffa7d37b320abc6.jpg"></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(12) 反向传播(back propagation)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在定义一个神经网络的过程中， 每个节点会被随机地分配权重和偏置。一次迭代后，我们可以根据产生的结果计算出整个网络的偏差，然后用偏差结合成本函数的梯度，对权重因子进行相应的调整，使得下次迭代的过程中偏差变小。这样一个结合成本函数的梯度来调整权重因子的过程就叫做反向传播。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">在反向传播中，信号的传递方向是朝后的，误差连同成本函数的梯度从输出层沿着隐藏层传播，同时伴随着对权重因子的调整。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(13) 分批(Batches)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">当在训练一个神经网络的时候，相对于一次性将所有的数据全输入进去，有一个更好的方法：先将数据随机地分为几个大小一致的数据块，再分批次输入。跟一次性训练出来的模型相比，分批训练能够使模型的适用性更好 。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(14) 周期(epochs)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">一个周期表示对所有的数据批次都进行了一次迭代，包括一次正向传播和一次反向传播，所以一个周期/纪元就意味着对所有的输入数据分别进行一次正向传播和反向传播。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">训练网络周期的次数是可以选择的，往往周期数越高，模型的准确性就越高，但是，耗时往往就越长。同样你还需要考虑如果周期/纪元的次数过高，那么可能会出现过拟合的情况。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(15) Dropout方法</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">Dropout是一个可以阻止网络过拟合的规则化方法。就像它的名字那样，在训练过程中隐藏的某些特定神经元会被忽略掉(drop)。这意味着网络的训练是在几个不同的结构上完成的。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">这种dropout的方式就像是一场合奏，多个不同结构网络的输出组合产生最终的输出结果。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224d413ffa7d37b320c2aa.jpg"></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"></h6><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(16) 分批标准化(Batch Normalization)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">分批标准化就像是人们在河流中用以监测水位的监察站一样。这是为了保证下一层网络得到的数据拥有合适的分布。在训练神经网络的过程中，每一次梯度下降后权重因子都会得到改变，从而会改变相应的数据结构。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224d623ffa7d37b320d372.jpg"></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">但是下一层网络希望能够得到与之前分布相似的数据，因此在每一次数据传递前都需要对数据进行一次正则化处理。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224d943ffa7d37b320ecd2.jpg"></p><h1 style="margin-top:20px;margin-bottom:20px;padding-left:15px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);line-height:1.2;font-size:20px;border-left:6px solid rgb(0,153,127);letter-spacing:1px;word-spacing:1px;">卷积神经网络</h1><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(17) 过滤器/滤波器(Filter)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">CNN中的滤波器，具体是指将一个权重矩阵，我们用它乘以输入图像的一部分，产生相应的卷积输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">比方说，对于一个28×28的图片，将一个3×3的滤波器与图片中3×3的矩阵依次相乘，从而得到相应的卷积输出。滤波器的尺寸通常比原始图片要小，与权重相似，在最小化成本的反向传播中，滤波器也会被更新。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">就像下面这张图片一样，通过一个过滤器，依次乘以图片中每个3×3的分块，从而产生卷积的结果。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224db53ffa7d37b320fc6a.jpg"></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(18) CNN(卷积神经网络)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">卷积神经网络通常用来处理图像数据，假设输入数据的形状为28×28×3(28pixels×28pixels×RGB Value)，那么对于传统的神经网络来说就会有2352(28×28×3)个变量。随着图像尺寸的增加，那么变量的数量就会急剧增加。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">因此，通过对图片进行卷积，可以减少变量的数目。随着过滤器沿着图像上宽和高的两个方向滑动，就会产生一个相应的2维激活映射，最后再沿纵向将所有的激活映射堆叠在一起，就产生了最后的输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">可以参照下面这个示意图。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224dd93ffa7d37b3210d7a.jpg"></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);text-align:right;line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(19) 池化(pooling)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">为了进一步减少变量的数目同时防止过拟合，一种常见的做法是在卷积层中引入池化层(pooling layer)。如下图所示，最常用的池化层的操作是将原始图片中每个4×4分块取最大值形成一个新的矩阵，这叫做最大值池化(max pooling)。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224e1e3ffa7d37b32129e4.jpg"></p><h6 style="margin-top:6px;margin-bottom:10px;margin-left:10px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(143,143,143);text-align:right;line-height:1.6;font-size:13px;letter-spacing:1px;word-spacing:1px;"><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">当然也有人尝试诸如平均池化(average pooling)之类的方式，但在实际情况中最大化池化拥有更好的效果。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(20) 补白(padding)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">如下图所示，补白(padding)通常是指给图像的边缘增加额外的空白，从而使得卷积后输出的图像跟输入图像在尺寸上一致，这也被称作相同补白(Same Padding)。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224e4a3ffa7d37b3213960.png"></p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">有效补白(Valid Padding)指的是保持图片上每个真实的像素点，不增加空白，因此在经历卷积后数据的尺寸会不断变小。(译者注：具体是指有效补白每次会丢弃最后不满足于一次卷积的像素点，比如说filter是3*3的，那么对于一行有32个pixel的数据，经历一次卷积后就会丢掉最后2个pixel；而通过相同补白，增加一个空白位，使每行有33个pixel，卷积后数据的尺寸不会变小。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(21) 数据增强(Data Augmentation)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">数据增强(Data Augmentation)指的是从已有数据中创造出新的数据，通过增加训练量以期望能够提高预测的准确率。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">比如在说数字识别中，我们遇到的数字可能是倾斜或旋转的，因此如果将训练的图片进行适度的旋转，增大训练量，那么模型的准确性就可能会得到提高。通过“旋转”的操作，训练数据的品质得到了提升，这种过程被称作数据增强。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="https://img.imgdb.cn/item/60224e5f3ffa7d37b3214082.png" ></p><h1 style="margin-top:20px;margin-bottom:20px;padding-left:15px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);line-height:1.2;font-size:20px;border-left:6px solid rgb(0,153,127);letter-spacing:1px;word-spacing:1px;">递归神经网络</h1><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(22) 递归神经元(Recurrent Neural Network)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">对于递归神经元来说，经由它自己处理过的数据会变成自身下一次的输入，这个过程总共会进行t次。如下图所示，将递归神经元展开就相当于t个不同的神经元串联起来，这种神经元的长处是能够产生一个更全面的输出结果。</p><p style="text-align:center;"><img style="width:auto;height:auto;visibility:visible;" src="http://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCQuhHtV3VIMiaEG6WfiaIqvt2mzM8pxxzic9JOKD8yVY14ibibp7X7uvM2rcAfnNFlgVC1gKcCgNbX32Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1"></p><p style="text-align:right;"><strong style="font-family:arial, sans-serif;font-size:13px;letter-spacing:1px;word-spacing:1px;background-color:rgb(255,255,255);color:rgb(0,153,127);">△</strong><span style="color:rgb(143,143,143);font-family:arial, sans-serif;font-size:13px;letter-spacing:1px;word-spacing:1px;background-color:rgb(255,255,255);">&nbsp;来源：cs231n</span></p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(23) 递归神经网络(RNN-Recurrent Neural Network)</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">递归神经网络通常被用于处理序列化的数据，即前一项的输出是用来预测下一项的 。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">递归神经网络中存在环的结构，这些神经元上的环状结构使得它们能够存储之前的数据一段时间，从而使得能够预测输出。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">与递归神经元相似，在RNN中隐藏层的输出会作为下一次的输入，如此往复经历t次，再将输出的结果传递到下一层网络中。这样，最终输出的结果会更全面，而且之前训练的信息被保持的时间会更久。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(24) 梯度消失问题</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">当激活函数的梯度很小时就会发生梯度消失问题。在反向传播的过程中，权重因子会被多次乘以这些小的梯度，因此会越变越小，随着递归的深入趋于“消失”， 使得神经网络失去了长程可靠性。这在递归神经网络中是一个较普遍的问题。</p><h2 style="margin-top:20px;margin-bottom:20px;font-family:arial, sans-serif;background-color:rgb(255,255,255);color:rgb(0,153,127);line-height:1.2;font-size:18px;letter-spacing:1px;word-spacing:1px;">(25) 梯度爆炸问题</h2><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">与梯度消失问题对应，当激活函数的梯度较大时，就会发生梯度爆炸问题。在反向传播的过程中，部分节点的大梯度使得他们的权重变得非常大，从而削弱了其他节点对于结果的影响，这个问题可以通过截断(即设置一个梯度允许的最大值)的方式来有效避免。</p><p style="font-size:16px;color:rgb(62,62,62);font-family:arial, sans-serif;background-color:rgb(255,255,255);margin-top:20px;margin-bottom:20px;letter-spacing:1px;word-spacing:1px;line-height:1.7;">【完】</p></div><p class="note note-warning">王瀚森 编译自 Analytics Vidhya <br>量子位 出品 | 公众号 QbitAI</p>]]></content>
    
    
    <categories>
      
      <category>深度学习与神经网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML入门指南</title>
    <link href="/2021/02/01/UML%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/02/01/UML%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>统一建模语言UML</p><a id="more"></a><p class="note note-warning">    本文授权转载于 蜗牛互联网 (见文末二维码) <br>    转载请联系授权(微信ID:919201148)<br>    作者博客：<a href="http://java4u.cn/">http://java4u.cn/</a></p><div id="section" class="post-content">    <h1><span id="一-前言">一、前言</span></h1><p>谈到面向对象技术的分析和设计，自然就离不开 UML。对于 UML 这个概念，很多程序员朋友耳熟能详，也有在用，但在工作中，一些朋友其实并不擅长使用 UML 甚至对 UML 这个东西模棱两可，也包括我自己。因此我希望可以结合自己的经验和实践，写一篇 UML 的入门文章，帮助做面向对象的程序员朋友能更好的利用它，从而顺利完成自己的编程设计工作。</p><p>以下是本文大纲。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554373064-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554373064-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554373064-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554373064-image.png" data-loaded="true"></a></div></p><h1><span id="二-从一个示例开始">二、从一个示例开始</span></h1><p>先举个现实世界的例子。我们上大学的时候，作为学生，每人都有一张学生证，会归属到一个班级，上学时可能会用到自行车。很多同学还会考驾照，挑放假时间练车，车可能是轿车也可能是皮卡。</p><p>如果想通过在线的方式记录以上的信息和行为，在软件世界中如何表达呢？</p><p>相信很多朋友的操作是，找到这段话里的主语和宾语，也就找到了这个例子中涉及的角色，然后通过动词来判断各个角色之间的关系和能力，最后用代码的方式来表达，产出可执行的程序。</p><p>像下图这样，识别出关键的实体和它们之间的关系。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554452353-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554452353-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554452353-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554452353-image.png" data-loaded="true"></a></div></p><p>用软件工程的方式，解决现实中的问题，是信息时代最明显的特点，这让我们的生活和工作变得更加便利。</p><p>但现实世界错综复杂，灵活多变，每个人的理解可能会有不同，从现实世界到软件世界的映射，就变得困难重重，一团乱麻。</p><p>如何让现实世界到软件世界映射变的简单容易，这就是 UML 要解决的问题。</p><h1><span id="三-什么是-uml">三、什么是 UML？</span></h1><p>UML 全称是 <strong>Unified Modeling Language</strong>（统一建模语言），它以<strong>图形的方式</strong>来描述软件的概念。</p><h2><span id="31-为什么称为语言">3.1 为什么称为语言</span></h2><p>先说语言，为什么称为语言？</p><p>名称的落脚点是语言。既然是语言，那么它就会<strong>具备语言的特性</strong>，比如结构上它由词汇和语法构成，功能上它能解决沟通问题。</p><p>你熟知的语言里比较多的应该是汉语和英语，如果从事软件行业，C 语言和 Java 语言你应该也不会陌生。英语和 Java 语言明显都是语言，却常常不被放在一起讨论，为什么？因为它们是不同维度的语言。英语是<strong>解决现实世界中人与人之间沟通问题</strong>的人类语言，Java 是<strong>解决软件世界中程序员与计算机之间沟通问题</strong>的计算机语言。</p><p>人类语言本质上是<strong>事实和观点的表达</strong>，计算机语言本质上是<strong>0 和 1 的表达</strong>。前者的表达形式是难以确定的，而且可能会产生歧义，所以才会有「被误解是表达者的宿命」这样的观点， 但后者就是确定性无歧义的 0 1 表达。</p><p>这么看来，UML 的目标是<strong>通过一定结构的表达，来解决现实世界到软件世界的沟通问题</strong>。</p><h2><span id="32-什么是建模">3.2 什么是建模</span></h2><p>再说建模，模是什么，需要怎么建？</p><p>建模简单讲，是指<strong>通过抽象的方式解决某个领域的问题</strong>。各个抽象角度共同组成了一个问题领域。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554671655-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554671655-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554671655-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554671655-image.png" data-loaded="true"></a></div></p><p>对于传统模型而言，建造它是为了证明这个问题领域下某件事物能否工作。当然它有前提，即建造模型的成本远远低于建造实物的成本。比如造飞机或造高楼。</p><p>对于软件模型而言，建造它是为了与他人沟通，也为了保存这个问题领域下软件设计的最终成果。当然它也有前提，就是模型比代码更说明问题。</p><p>比如购物这个问题，甲可以在淘宝上买衣服，乙可以在亚马逊上买书，丙可以在京东上买手机。</p><p>谁买东西？是甲、乙和丙，他们都能抽象成人。</p><p>买什么东西？有衣服、书和手机，它们都能抽象成货。</p><p>在哪里买？在淘宝，亚马逊和京东，它们都能抽象成场。</p><p>整体抽象一下就是人到场里买货。所以购物这个场景所抽象出来的人货场，就用来解决零售领域的问题。当然还可能会有些规则，比如成为注册会员才能发生交易。</p><p>我们会发现，<strong>一个特定的事件（比如购物）里，会有特定的人的行为（比如甲乙丙要上电商网站），会有特定的物（比如货），有特定的规则（比如注册会员）</strong>，共同完成购物这件事。</p><pre class="highlight"><span class="line">特定的事 = 特定的人的行为 + 特定的物 + 特定的规则</span><br></pre><p>在人货场这个抽象角度里，就会涉及到很多特定的事，包括会员注册，会员下单，会员支付，商家发货，快递公司邮寄等等。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554781255-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554781255-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554781255-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610554781255-image.png" data-loaded="true"></a></div></p><p>模简单讲，就是<strong>人、事、物和规则</strong>。</p><p>人是一切的中心，人要做事，做事就会使用一些物并产生另一些物，同时做事需要遵循一定的规则。</p><p><strong>人驱动系统，事体现过程，物记录结果，规则是控制</strong>。</p><p>建立模型的关键就是<strong>弄明白有什么人，什么人做什么事，什么事产生什么物，中间有什么规则，再把人、事、物之间的关系定义出来</strong>，一个模型也就基本成型了。</p><h2><span id="33-统一的意义在哪">3.3 统一的意义在哪</span></h2><p>统一的普遍意义是<strong>形成标准</strong>。所谓标准，就是<strong>所有人都明白的表述，所有人都遵从的格式</strong>。标准可以<strong>让信息在人群中无障碍地流通</strong>，即使这些信息来自不同地域、不同文化、不同社会或不同组织。</p><p>比如美元作为国际统一使用的货币方便了全球的经济贸易，我们国家普及普通话方便了不同地区的交流沟通。</p><p>在软件世界，任何一种组件化开发模式背后都有一个标准在规范和指导，比如 Java 的 JSR 标准。<strong>有了标准，编程就容易组件化，协作效率也会提升很多</strong>。对 UML 来说，这就是统一的意义。</p><h1><span id="四-为什么需要-uml">四、为什么需要 UML</span></h1><p>一个软件项目要经历<strong>业务调研、立项、需求采集、架构设计、编码开发和测试验证</strong>等多个环节。</p><p>每个环节可能角色并不相同，<strong>同样的文档同样的话语越向后传递就越容易失真</strong>。因此就容易出现最终交付的产品不是客户真正想要的这种情况。</p><p>如何避免角色间信息传递的失真，保证信息能被准确的传达和准确的理解？一种好的办法就是<strong>大家使用标准化的语言。</strong></p><p>统一建模语言(UML)就试图用标准化的语言来覆盖整个软件过程，让不同团队不同角色可以用相同的语言顺畅的沟通。</p><p>在信息传播方面，图形相对于文字，人脑的接受能力显然更强。因此，<strong>UML 采用了「可视化」的图形方式来定义语言。</strong></p><h1><span id="五-uml-的适用场景">五、UML 的适用场景</span></h1><p>UML 既可以描述某个问题领域，也可以表达构思中的软件设计，还可以描述已经完成的软件实现。</p><p>它适用于面向对象分析设计的整个过程。这个过程可以分为三个阶段，如下图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555171587-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555171587-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555171587-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555171587-image.png" data-loaded="true"></a></div></p><p>第一个阶段是<strong>通过建模将现实世界转为业务模型</strong>。业务模型真实映射了参与者（业务活动的驱动者）在现实世界的行为。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555264970-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555264970-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555264970-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555264970-image.png" data-loaded="true"></a></div></p><p>从图里可以看到，现实世界映射到业务模型后，是使用 <strong>参与者</strong> 和 <strong>用例</strong> 这两个 UML 的核心元素表达的。参与者作为一个特定事件的驱动者，用例则描述了这个驱动者的业务目标。文章后边也会提到这两个元素。</p><p>第二个阶段是<strong>对业务模型概念化，建立适合计算机理解和实现的模型，也就是概念模型</strong>，或者叫分析模型。分析模型<strong>向上映射了原始需求</strong>，向下<strong>为计算机实现规定了一种高层次的抽象</strong>，是一种过渡模型。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555367200-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555367200-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555367200-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555367200-image.png" data-loaded="true"></a></div></p><p>现实世界千差万别的业务，都用 边界、控制和实体这几个核心元素来描述，同时也引入了 包、组件 这些与现实世界毫不相干的概念做包装。</p><p>第三个阶段是<strong>对概念模型实例化，得到相对详细的设计模型。</strong></p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555451955-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555451955-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555451955-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555451955-image.png" data-loaded="true"></a></div></p><p>在设计模型中，概念模型中的边界类可以被转化为操作界面或者系统接口；控制类可以被转化为计算程序或控制程序，例如工作流、算法体等；实体类可以转化为数据库表、XML 文档或者其他带有持久化特征的类。</p><p><strong>同样的概念模型会因为选择不同而得到不同的设计模型</strong>。比如技术选型上使用不同的编程语言，不同的中间件就会得到不同的设计。</p><p>为什么需要这一道转换呢？</p><p>因为“边界”、“控制”、“实体”这些对象化的概念，虽然是计算机可以理解的，但它并不是真正的对象实例，也就是说它们并不是可执行代码，概念模型只是纸上谈兵。真正的对象世界行为是由 Java 类、C++ 类、JSP 等这些可执行代码构成的。</p><p>换句话说，<strong>设计模型是概念模型在特定环境和条件下的实例化</strong>，实例化后的对象行为执行了概念模型描述的那些信息。</p><p>以下是面向对象分析设计的完整过程，它表达了现实世界是怎么通过 UML 映射到对象世界的。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555589309-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555589309-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555589309-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555589309-image.png" data-loaded="true"></a></div></p><h1><span id="六-uml-的组成结构">六、UML 的组成结构</span></h1><p>前面花了比较大的篇幅分析了 UML 的定位和适用场景，目的是帮助读者建立对 UML 整体系统性的认知，而不是过早的陷入 UML 的使用细节里。我们要应用一项技术或工具，不能单纯的因为它的酷炫或者说业界都在用所以我们要用，而应该结合自己的使用场景以及技术或工具的特点，来确认这项技术或工具究竟是不是我们需要的。</p><p>在读者了解 UML 在面向对象分析设计领域优秀的特性之后，我们再来看看 UML 的一些细节。</p><p>凡是语言，都会存在基本词汇和语法。</p><p>那么对应到 UML 里，基本词汇就是核心元素，语法就是核心视图。</p><p>UML 的组成结构如下图：</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555767974-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555767974-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555767974-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555767974-image.png" data-loaded="true"></a></div></p><h2><span id="61-核心元素">6.1 核心元素</span></h2><p>我们先介绍核心元素，下图是大纲。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555818329-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555818329-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555818329-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555818329-image.png" data-loaded="true"></a></div></p><h3><span id="611-版型">6.1.1 版型</span></h3><p>版型：也称「类型」或「构造型」。是对 UML 元素基础定义的扩展，在元素基础定义的基础上赋予特别的含义，使得这个元素适用于特定的场合。</p><p>比如，我们前边提到的「边界类」、「实体类」、「控制类」都是类的版型。</p><h3><span id="612-参与者">6.1.2 参与者</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555893894-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555893894-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555893894-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555893894-image.png" data-loaded="true"></a></div></p><p><strong>参与者定位</strong>：事件的第一驱动者，也是系统的服务方。比如你在电商网站购物，你就是参与者。</p><h3><span id="613-用例">6.1.3 用例</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555913959-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555913959-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555913959-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555913959-image.png" data-loaded="true"></a></div></p><p><strong>用例定位</strong>：系统执行的一系列操作，并生成参与者可以观察的值。比如你在电商网站交易，会生成在线订单，用户下单就是一个用例。</p><p><strong>用例版型：</strong></p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555937504-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555937504-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555937504-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610555937504-image.png" data-loaded="true"></a></div></p><ul><li>业务用例：<strong>用于需求阶段业务领域建模</strong>。与计算机系统建模无关，比如下单可以不依赖在线服务，而只是线下签署协议。业务建模的目标是让需求人员和客户能够达成共识。</li><li>业务用例实现：<strong>业务用例的一种实现方式</strong>，一个业务用例可以有多种实现方式。比如下单后的支付，可以用现金，也可以银行卡转账，还可以第三方支付。</li></ul><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556022968-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556022968-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556022968-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556022968-image.png" data-loaded="true"></a></div></p><ul><li>概念用例：<strong>用于获取业务模型中的关键概念，分析出核心业务结构</strong>。业务架构就是概念建模阶段产生，同时为系统建模阶段提供重要指导。比如用户下单这个用例，可以从实现过程中获得一些核心业务，并把它们展现出来。</li></ul><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556065419-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556065419-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556065419-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556065419-image.png" data-loaded="true"></a></div></p><ul><li>系统用例：<strong>用于定义系统范围、获取功能性需求</strong>。也就是我们常挂在嘴边的用例。像业务用例中提到的线下签约的方式，就不会纳入到系统用例中，但如果是电子签约的话，就可以成为系统用例了。</li><li>系统用例实现：<strong>系统用例的一种实现方式</strong>，一个系统用例可以有多种实现方式。比如下单后的支付，可以接入微信支付接口，也可以接入支付宝支付接口。</li></ul><p>你会发现，同是<strong>用例的版型，业务用例与系统用例的区别就在于</strong>业务用例是客户业务视角，系统用例是系统视角。</p><h3><span id="614-边界">6.1.4 边界</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556172530-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556172530-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556172530-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556172530-image.png" data-loaded="true"></a></div></p><p><strong>边界定位</strong>：用于业务建模和系统建模阶段的分析，保证<strong>分析粒度在一定的范围内</strong>，不会扩散。</p><p>比如一个电商网站按领域职责作为边界，会有店铺域、商品域、会员域、交易域、支付域和营销域等。各域只负责域内的事情，就能够减少混乱紧耦合的局面。</p><blockquote><p>一个好的分析和设计如同一筐带壳的鸡蛋，清清爽爽；一个差的设计如同一堆打碎了壳的鸡蛋，粘粘糊糊。壳，是好坏的关键。</p></blockquote><h3><span id="615-业务实体">6.1.5 业务实体</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556200497-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556200497-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556200497-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556200497-image.png" data-loaded="true"></a></div></p><p><strong>业务实体定位</strong>：它代表<strong>参与者执行业务用例时所处理或使用的事物</strong>，特别用于在<strong>业务建模阶段</strong>建立领域模型。业务实体是类（class）的一种版型。</p><p><strong>业务实体的结构</strong>：包含属性和方法。属性用来保存业务实体特征，方法用来访问业务实体。比如一台电视，把它看成一个业务实体的话，它的属性有运行状态和音量，它的方法就是遥控器，我们可以开、关、调声音，但是我们不可以试图让它飞起来——因为它没有这样的方法。</p><h3><span id="616-包">6.1.6 包</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556241970-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556241970-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556241970-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556241970-image.png" data-loaded="true"></a></div></p><p><strong>包定位</strong>：容纳并为其他 UML 元素分类。比如 Java 后端经常会提供 jar 包给接入方使用。</p><h3><span id="617-分析类">6.1.7 分析类</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556273177-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556273177-image.png" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556273177-image.png" class="lozad post-image loaded" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556273177-image.png" data-loaded="true"></a></div></p><p><strong>分析类定位</strong>：用于代表系统中主要的职责簇，由此产生系统的设计类和子系统。</p><ul><li>边界类：用于<strong>对系统外部环境和内部运作之间的交互</strong>进行建模。比如现实世界的窗户，计算机世界的网页。</li><li>控制类：用于<strong>对用例特有的控制行为</strong>进行建模。比如显示逻辑和业务逻辑通过控制层分离的 MVC 架构。</li><li>实体类：用于<strong>对需要存储的信息和相关行为</strong>进行建模。源于业务模型中的<strong>业务实体</strong>。</li></ul><p>分析类的抽象层次较高，比设计和实现要稳定很多，因此方便维护，也更容易获得一个稳定架构来指导整个软件的开发。</p><h3><span id="618-设计类">6.1.8 设计类</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556321186-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556321186-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556321186-image.png"></a></div></p><p><strong>设计类定位</strong>：是系统实施中一个或多个对象的抽象，由此<strong>映射到实现代码</strong>，依赖于实施语言。</p><p><strong>设计类结构</strong>：</p><ul><li>类型：对对象某一方面特征的归纳和抽象。映射到编码中的 class。</li><li>属性：对象特征。映射到编码中的 field。</li><li>方法：访问对象属性的唯一途径。映射到编码中的 method。</li></ul><h3><span id="619-关系">6.1.9 关系</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556360552-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556360552-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556360552-image.png"></a></div></p><p><strong>关系定位</strong>：抽象出<strong>对象之间的联系</strong>，让对象构成某个特定的结构。</p><p>关系分为以下几种：</p><ul><li><strong>关联（association）</strong><ul><li>关系：是一种<strong>拥有</strong>的关系，即一个类知道另一个类的属性和方法；比如老师与学生可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</li><li>箭头和连线：<strong>带普通箭头的实心线</strong>，指向被拥有者。</li><li>适用场景：类图。</li></ul></li><li><strong>依赖（dependency）</strong><ul><li>关系：是一种<strong>使用</strong>的关系，即一个类的实现需要另一个类的协助，是一种弱关系，随运行场景变化。比如削苹果时，人依赖于刀，脱离了这个场景，依赖关系就不存在了。</li><li>箭头和连线：<strong>带箭头的虚线</strong>，指向被使用者。</li><li>适用场景：类图。</li></ul></li><li><strong>泛化（generalization）</strong><ul><li>关系：是一种<strong>继承</strong>的关系，比如猫是动物的一种。</li><li>箭头和连线：<strong>带三角的实线</strong>，箭头指向父类。</li><li>适用场景：类图。</li></ul></li><li><strong>实现（realization）</strong><ul><li>关系：是一种<strong>实现</strong>的关系，比如用例和用例实现的关系，接口与实现类的关系。</li><li>箭头和连线：<strong>带三角的虚线</strong>，箭头指向用例实现或接口类。</li><li>适用场景：用例图，类图。</li></ul></li><li><strong>聚合（aggregation）</strong><ul><li>关系：是<strong>整体与部分</strong>的关系，且<strong>部分可以离开整体而单独存在</strong>。生命周期各自独立。如车和轮胎是聚合关系，轮胎离开车仍然可以存在。</li><li>箭头和连线：<strong>带空心菱形的实线</strong>，菱形指向整体。</li><li>适用场景：类图。</li></ul></li><li><strong>组合（composition）</strong><ul><li>关系：是<strong>整体与部分</strong>的关系，但<strong>部分不能离开整体而单独存在</strong>。同生同灭。如公司和部门是组合关系，没有公司就不存在部门。</li><li>箭头和连线：带实心(黑色实心：要死一起死，良心是黑的)菱形的实线，菱形指向整体。</li><li>适用场景：类图。</li></ul></li></ul><p><strong>关联关系和依赖关系的区别</strong>：</p><ul><li>关联关系是静态天然的联系，依赖关系是动态临时的联系。</li></ul><p>此外还有只用于用例中的关系：</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556435010-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556435010-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556435010-image.png"></a></div></p><ul><li><strong>扩展（extends）</strong><ul><li>关系：<strong>用于在用例模型</strong>中说明向基本用例中的某个扩展点插入扩展用例。</li><li>箭头和连线：带箭头的虚线加版型<code>&lt;&lt;extends&gt;&gt;</code>。</li><li>特点：用例可选。</li></ul></li><li><strong>包含（include）</strong><ul><li>关系：<strong>用于在用例模型中</strong>说明在执行基本用例的用例实例过程中插入的行为段。</li><li>箭头和连线：带箭头的虚线加版型<code>&lt;&lt;include&gt;&gt;</code>。</li><li>特点：用例必需。</li></ul></li></ul><h3><span id="6110-组件">6.1.10 组件</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556565583-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556565583-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556565583-image.png"></a></div></p><p><strong>组件定位</strong>：实现特定功能的逻辑代码模块。比如分布式应用架构下，将业务目标拆成多个功能，每个功能作为组件独立部署。这样这些组件也能被其他场景复用。</p><h3><span id="6111-节点">6.1.11 节点</span></h3><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556581619-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556581619-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556581619-image.png"></a></div></p><p><strong>节点定位</strong>：表示应用程序的部署单元。比如分布式应用的环境中，服务器或设备会有很多，就需要通过节点来体现物理部署的情况。</p><h2><span id="62-核心视图">6.2 核心视图</span></h2><p>前面我们介绍了 UML 的核心元素，这些元素分别应用于面对对象分析设计的各个阶段，正是它们之间的相互组合，才形成了 UML 里的各种视图，最终指导软件设计。</p><p>接下来讲讲核心视图里的结构视图和行为视图，下图是大纲。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556627990-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556627990-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556627990-image.png"></a></div></p><h3><span id="621-结构视图">6.2.1 结构视图</span></h3><p>结构视图也称为<strong>静态视图</strong>。静态视图就是<strong>表达静态事物</strong>的。它只描述<strong>事物的静态结构</strong>，而不描述其动态行为。这里简要介绍的静态视图包括<strong>用例图，对象图，类图，组件图，包图和部署图</strong>。</p><h4><span id="6211-用例图">6.2.1.1 用例图</span></h4><p>用例图包含<strong>参与者、用例和关系</strong>这三种核心元素，不同的视角可以得到不同的用例视图，它展现了系统的功能性需求。</p><p>所谓不同的视角，可以对应面向对象分析设计的三阶段。</p><ul><li>建立业务模型阶段，产出<strong>业务用例视图</strong>。</li><li>建立概念模型阶段，产出<strong>概念用例视图</strong>。</li><li>建立设计模型阶段，产出<strong>系统用例视图</strong>。</li></ul><p>就借阅图书的用例而言，业务用例视图如下，它是完全从业务角度出发，和计算机系统无关。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556691399-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556691399-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556691399-image.png"></a></div></p><p>而我们在业务用例分析的过程中，可以分解出一些关键的概念用例，并建立它们之间的关系，如下图(bu 表示业务用例，cu 表示概念用例)。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556714861-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556714861-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556714861-image.png"></a></div></p><p>我们对业务用例进行分析以后，就可以绘制系统用例视图。但不是所有的业务用例都有系统用例对应，比如检查借阅证可能是手工工作，就不需要纳入系统建设范围。</p><p>下图是借阅图书的系统用例视图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556729370-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556729370-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556729370-image.png"></a></div></p><h4><span id="6212-类图">6.2.1.2 类图</span></h4><p>类图用于<strong>展示系统中的类及其相互之间的关系。</strong></p><p>类图建模常用的方式是从<strong>概念层，到说明层，最后到实现层</strong>这么一个抽象层次逐步降低和细化的过程。</p><p><strong>概念层类图位于业务建模阶段</strong>，这个阶段采用<strong>业务实体</strong>这个核心元素来表示。</p><p>下图是网上购物的业务实体图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556778574-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556778574-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556778574-image.png"></a></div></p><p>网上购物主要由商品、订单、支付账户这几个关键类构成，这几个类的交互能够完成网上购物这个业务目标。</p><p><strong>说明层类图位于概念建模阶段</strong>，这个阶段采用<strong>分析类</strong>这个核心元素来表示。</p><p>下图展示了网上购物的说明层类图，这个类图表达了从计算机的视角来说，网上购物这个业务目标是由哪些类来完成的，这些类的接口保证了这个业务目标的达成。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556794424-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556794424-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556794424-image.png"></a></div></p><p><strong>实现层类图位于设计建模阶段</strong>，这个阶段采用<strong>设计类</strong>这个核心元素来表示。</p><p>到了这一层，类图可视作伪代码，因此，在这个层次上，类必须明确采用哪种实现语言、什么设计模式、什么通信标准、遵循什么规范等。</p><p>下图展示了查询商品功能的类图。可以看到，到了实现层类图，类描述和类关系已经是伪代码级别了。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556808346-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556808346-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556808346-image.png"></a></div></p><p>由此可见，在软件生命周期的不同阶段，类图也有三种不同的表达，他们分别是<strong>概念层类图，说明层类图和实现层类图</strong>。</p><p>很多朋友在建模的时候只会用到实现层类图，并非他们对问题领域足够了解，而是不清楚类图也分了这么三层。</p><h4><span id="6213-对象图">6.2.1.3 对象图</span></h4><p>对象图是类图的实例，标识和类图基本相同。由于对象存在生命周期，对象图只能在系统某一时间段存在，因此对象图可以被想象成正在运行的系统在某一时刻的快照。</p><p>比如一个正在运行的列车，如果用对象图来描述，某个时间点你会发现以下静态图片：</p><ul><li>当前的运行状态（运行中或停车中）</li><li>当前的乘客数量。（如果捕捉在不同的时间，该值会变化）</li></ul><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556826416-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556826416-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556826416-image.png"></a></div></p><h4><span id="6214-包图">6.2.1.4 包图</span></h4><p>在实际的项目中，建模过程获得的元素可能是非常多的，如果将这些元素的关系都绘制出来，看上去就会特别乱，特别复杂，也难以识别。</p><p>那为了更好的理解和管理这些建模元素，我们就需要<strong>有规律的对元素进行组织</strong>。包图就起到了这么一个作用，通过包这个容器，可以<strong>从大到小、从粗到细地将建模元素组织起来</strong>，便于我们的<strong>分析，交流和细化</strong>。</p><p>下图是网上购物的领域包图，它表达了关键业务领域及其依赖关系。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556900623-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556900623-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556900623-image.png"></a></div></p><p>下图展示了查询商品功能的类层次，它表达了实现类位于哪个层次的软件架构的观点。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556910290-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556910290-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556910290-image.png"></a></div></p><h4><span id="6215-组件图">6.2.1.5 组件图</span></h4><p>当有些包能够<strong>被多个场景重复使用</strong>，那这个包就可以认为有着特定的功能，能够完成特定的目标。</p><p>这种情况下，包就可以定义为组件，<strong>组件是一种特殊的包，既起到了普通包组织和容纳的作用，又能完成特定的功能</strong>。</p><p>比如模块（登录模块），类库（Java Guava 包）。</p><p>下图可以表达组件实现的过程，通过第三方软件或者面向对象分析设计过程中产生的各种包，可以定义组件。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556935781-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556935781-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556935781-image.png"></a></div></p><p>组件可以按功能分为以下几类：模块、子系统、库、可执行文件和程序包等等。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556945710-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556945710-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556945710-image.png"></a></div></p><h4><span id="6216-部署图">6.2.1.6 部署图</span></h4><p>部署图描述了<strong>物理上系统运行时的结构</strong>，包括系统中<strong>硬件的分布以及软件部署到硬件上的具体方式</strong>。</p><p>部署图用于<strong>设计建模阶段</strong>，采用<strong>节点和关系</strong>两种核心元素来绘制。常用于分布式应用环境和多设备应用环境。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556960292-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556960292-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556960292-image.png"></a></div></p><p>上图是一个简单的部署图，表达了客户端比如浏览器这个节点，会请求到 Web 服务器节点，最后通过数据库服务器节点返回数据。如果涉及分布式环境，就要考虑多个 Web Server，多个 Database Server，甚至考虑多机房，异地等物理层面的部署方式。</p><h3><span id="622-行为视图">6.2.2 行为视图</span></h3><p>结构视图介绍完，我们讲讲行为视图。</p><p>行为视图也称为<strong>动态视图</strong>。动态视图就是描述<strong>事物动态行为</strong>的。动态视图不能独立存在，它必须<strong>基于一个静态视图或者 UML 元素</strong>，说明在静态视图规定的事物结构下它们的<strong>动态行为。</strong></p><p>这里简要介绍的动态视图包括状态图、活动图、时序图和协作图。</p><h4><span id="6221-状态图">6.2.2.1 状态图</span></h4><p>状态图<strong>也称状态机</strong>，它<strong>描述了一个对象的生命周期</strong>，你可以把它理解成一台运行中的机器，这台机器<strong>负责这个对象在固定几个状态间的流转。</strong></p><p>这个对象可以是<strong>业务实体对象</strong>，也可以是<strong>分析类对象</strong>，还可以是<strong>设计类对象</strong>。也就是说，在面向对象分析设计的<strong>三个阶段</strong>（业务建模，概念建模，设计建模），都可以用状态图来表达。</p><p>下图是一个产品的生命周期状态图。绿色部分是状态图相关的元素，红色部分是元素的解释。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556985617-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556985617-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610556985617-image.png"></a></div></p><p>从图中，我们可以看到，状态图有以下关键元素：</p><ol><li>初始状态：它是状态机的<strong>起始位置</strong>，不需要事件的触发。用实心圆圈表示。</li><li>状态：状态是对象<strong>执行某项活动或者等待某个事件时的条件</strong>。比如要想执行产品入库动作，产品得是未入库的状态，如果想销售某个产品，产品得是入库的状态。</li><li>转移：转移是<strong>两个状态之间的关系</strong>，它表示当发生指定事件并且满足指定条件时，第一个状态中的对象将执行某些操作并进入第二个状态。比如产品入库这个动作，就将产品的状态从未入库转移到了已入库。</li><li>事件：事件是一个<strong>特定的动作或行为</strong>，有时候也包括系统时钟之类的定时器。如果条件满足，事件的发生将触发一个转移。比如产品销售这个动作，出发产品从已入库状态转移至已销售状态。</li><li>条件：条件是一个<strong>布尔表达式</strong>，当事件发生时将检查这个表达式的值。条件求值结果可能决定转移的分支，或者拒绝转移。条件有可能引用当前状态。比如产品合不合格这个布尔判断，决定了产品是可被销售，还是不可被销售。</li><li>最终状态：最终状态表示<strong>状态机执行结束</strong>，或者对象生命周期结束。用带环的实心圆圈表示。</li></ol><h4><span id="6222-活动图">6.2.2.2 活动图</span></h4><p>活动图描述了为了<strong>完成某一个目标需要做的活动</strong>以及这些<strong>活动的执行顺序</strong>。</p><p>UML 中有两个层面的活动图，一种是<strong>用例活动图</strong>，它用于描述<strong>用例场景</strong>，常用于业务建模阶段，另一种是<strong>对象活动图</strong>，用于描述<strong>对象交互</strong>，常用于设计建模阶段。</p><p>下图是一个登机手续办理的用例活动图。绿色部分是活动图相关的元素，红色部分是元素的解释。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557039800-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557039800-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557039800-image.png"></a></div></p><p>从图中，我们可以看到，活动图有以下几个关键元素：</p><ul><li>起始点：起始点<strong>标记业务流程的开始</strong>。一个活动图仅有一个。用实心圆圈表示。</li><li>活动：活动是业务流程中的一个<strong>执行单元</strong>。比如办理登机手续需要出示机票和身份证这样的动作。</li><li>判断：判断<strong>根据某个条件进行决策</strong>，执行不同的流程分支。比如身份核对决定了你能否继续办理登机手续。</li><li>基本流：基本流表示<strong>最主要、最频繁使用的</strong>、默认的业务流程分支。比如身份核对的正常分支。</li><li>支流：支流是进行判断后走进的<strong>业务流程分支</strong>。比如图中无行李分支。</li><li>异常流：异常流表示<strong>非正常的、不是业务目标期待的、容错性的、处理意外情况</strong>的业务流程分支。比如身份证核对错误。</li><li>同步：同步分为<strong>同步起始和同步汇合</strong>。<ul><li>同步起始表示从它<strong>开始多个支流并行执行</strong>。比如托运行李的处理和登机牌的打印操作，可以并行。</li><li>同步汇合表示<strong>多个支流同时到达后再执行后续活动</strong>。</li></ul></li><li>结束点：结束点表示<strong>业务流程的终止</strong>。一个或多个。</li></ul><p>用例活动图常常是从业务的角度上，分析要完成某个目标，要执行哪些活动。如果在系统设计的角度上，要表达完成目标需要的活动，就需要用到对象活动图。</p><p>比如根据查询商品的对象交互过程，就能绘制出以下的对象活动图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557185602-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557185602-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557185602-image.png"></a></div></p><p>虽然 UML 允许用活动图绘制对象交互，但实际工作中，<strong>我从来没用过</strong>。因为 UML 有其他更好的工具来绘制对象交互图，比如接下来要讲的时序图。</p><h4><span id="6223-时序图">6.2.2.3 时序图</span></h4><p>时序图用于描述按<strong>时间顺序排列的对象之间的交互模式</strong>。</p><p>前面类图那一节有提过类有三个层次的观点：<strong>概念层、说明层和实现层</strong>，分别对应于面向对象分析设计的<strong>业务建模阶段、概念建模阶段和设计建模阶段</strong>，相应的，也可以在这三个层次上分别对<strong>业务实体对象、分析类对象和设计类对象</strong>绘制<strong>业务模型时序图、概念模型时序图和设计模型时序图</strong>。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557289294-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557289294-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557289294-image.png"></a></div></p><p>接下来介绍三种时序图。</p><p>业务模型时序图用于为<strong>领域模型中的业务实体交互建模</strong>，目标是<strong>实现业务用例</strong>。</p><p>上一节提到的活动图，可以帮助我们发现业务实体，活动图也可以很轻易的转换成时序图，下图是网上购买商品的业务模型时序图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557368470-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557368470-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557368470-image.png"></a></div></p><p>时序图中会涉及一些 UML 元素，这里列举常用的几个：</p><ul><li>对象：表示<strong>参与交互的对象</strong>。每个对象都有一条生命周期线，对象被激活时，生命周期线上会出现一个长条（会话），表示对象的存在。</li><li>生命周期线：表示<strong>对象的存在</strong>。当对象被激活时，生命周期线上出现会话，表示对象参与了这个会话。</li><li>消息：表示<strong>对象间交互所发生的动作</strong>。由一个对象的生命周期线指向另一个对象的生命周期线。常见的消息类型有以下几种：<ul><li>简单消息：<strong>向右的实线箭头</strong>，这种最为常用。</li><li>返回消息：<strong>源消息的返回体，并非新消息</strong>。用向左的单向虚线箭头表示。<strong>一般不需要为每个源消息都绘制返回消息</strong>，一方面源消息默认情况下都有返回消息，另一方面过多的返回消息会让图变得更复杂。</li><li>同步消息：表示<strong>发出消息的对象将停止所有后续动作</strong>，一直等到接收消息方响应。用向右带×的单向实线箭头表示。同步消息将阻塞源消息所有行为。通常程序之间的方法调用都是同步消息。</li><li>异步消息：表示源消息发出消息后不等待响应，而可以继续执行其他操作。<strong>用向右的单向上箭头表示</strong>。异步消息一般需要消息中间件的支持，如 MQ 等。</li></ul></li><li>会话：表示<strong>一次交互</strong>，在会话过程中<strong>所有对象共享一个上下文环境</strong>。例如操作上下文。</li><li>销毁：表示<strong>生命周期的终止</strong>。绘制在生命周期线的末端，一般没有必要强调。</li></ul><p>业务模型时序图是<strong>业务建模阶段的产物</strong>，它展现了业务的实际需求，因此使用的<strong>描述语言应当采用业务术语</strong>。</p><p>进入概念建模阶段，可以采用<strong>分析类绘制概念模型时序图</strong>。和业务模型时序图相比，同样是展现业务需求，不同点在于<strong>分析类代表了系统原型</strong>，所以这个阶段的时序图已经带有了计算机层面的理解。</p><p>因此，概念模型时序图<strong>既保留了实际业务需求</strong>，又得到了<strong>计算机实现的基本理念</strong>。如下图所示。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557468730-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557468730-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557468730-image.png"></a></div></p><p>可以看到，在概念模型时序图里，相对于业务模型时序图，我们的表达增加了安全认证和商品目录。这是因为我们实际在做登录这个功能时，我们的软件系统需要关心身份核验。我们在获取商品时，为了避免杂乱需要对其进行分类。</p><p>另外，我们的业务实体转为分析类进行表达，<strong>网站作为边界类</strong>，用于隔离用户操作和系统行为。<strong>安全认证作为控制类</strong>，用于决定是否能成功登录网站。<strong>商品目录和商品作为实体类</strong>，用于表达用户实际想看到或者操作的实体信息。 </p><p>分析类展示出来的已经是系统实现的原型，进入设计建模阶段，我们做的工作就是要<strong>选择合适的实现方式来实现这个原型</strong>。</p><p>设计建模阶段，我们采用设计模型时序图来实现概念模型中的交互。</p><p>设计模型时序图使用设计类作为对象绘制，也是我们日常开发设计中最为常用的动态视图。以下是商品查询的设计模型时序图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557512368-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557512368-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557512368-image.png"></a></div></p><p>可以看到，在设计模型时序图里，<strong>消息会细致到方法级别</strong>。因为在这个阶段，相关的技术选型，比如编程语言，交互协议，中间件等已经比较明确了。</p><p>时序图除了在建模的三个阶段使用外，当你需要<strong>表达对象的交互</strong>，或者想<strong>分析对象的职责和接口</strong>时，都可以使用时序图。</p><h4><span id="6224-协作图">6.2.2.4 协作图</span></h4><p>协作图和时序图一样，也是描述对象之间的交互模式，不同的是，时序图在意的是<strong>对象交互的执行顺序</strong>，而协作图在意的是<strong>对象间的结构关系。</strong></p><p>因此，时序图适用于<strong>获得对调用过程的理解</strong>，而协作图适用于<strong>获得对对象结构的理解。</strong></p><p>协作图可以和时序图互相转换，对应时序图的三种表达方式，协作图也分为<strong>业务模型协作图</strong>，<strong>概念模型协作图</strong>和<strong>设计模型时序图</strong>。本文只介绍业务模型协作图，另外两种协作图可以由相应的时序图推导，这里就不赘述了。</p><p>业务模型协作图同样采用业务实体来绘制，目标也是实现用例场景。下图是网上购买商品的业务模型协作图。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557571902-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557571902-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557571902-image.png"></a></div></p><p>可以看到，协作图和时序图相比，对象间的结构一目了然，很容易<strong>知道哪些消息会影响哪些对象或者哪些对象需要提供哪些接口</strong>。但在执行顺序的表达上就很弱，必须依赖消息文本里的数字。</p><p>以下是协作图常用的 UML 元素：</p><ul><li>对象：表示<strong>参与协作的对象</strong>。</li><li>对象关联：用于<strong>连接两个对象</strong>，表示二者的关联。这种关联是临时的，只在本次交互中有效。</li><li>消息：和时序图中的消息定义一致。<ul><li>消息序号：表明<strong>消息传递的先后顺序</strong>。</li></ul></li></ul><h3><span id="623-小结">6.2.3 小结</span></h3><p>本节介绍了 UML 的核心视图，我们再看下核心视图的大纲。</p><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557638884-image.png" aria-label="illustration" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557638884-image.png" class="lozad post-image" src="https://gitee.com/java4u/resources/raw/master/2021-1-14/1610557638884-image.png"></a></div></p><p>核心视图分静态视图和动态视图。静态视图<strong>表达事物的结构性观点</strong>，动态视图<strong>表达事物的行为性观点</strong>。</p><p>一个好的建模，结构性和行为性都不可或缺，既要说明<strong>该事物长什么样子</strong>，又要说明<strong>该事物应该怎么用</strong>。</p><h1><span id="七-总结">七、总结</span></h1><p>本文从一个示例开始，引入了 UML 的概念，介绍了<strong>什么是 UML，为什么要用 UML以及什么时候用 UML</strong>。我们了解一个事物，<strong>知其然也要知其所以然</strong>。</p><p>然后介绍了 UML 的组成结构，从元素和视图的角度出发，讲解了绘制图形的方法和相关概念。文中也给出了很多我亲手绘制的样例视图，如有错误之处，还望读者指摘。</p><p><strong>纸上得来终觉浅，绝知此事要躬行</strong>。知道和做到总有一段距离，重在实践。</p><p>希望这篇文章对从事面向对象编程的读者朋友能够有所启发，欢迎和我一起交流，也欢迎<strong>转发</strong>给有需要的朋友。</p><p>（完）</p><hr><p><div class="gallery"><a href="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png" aria-label="illustration" data-caption="欢迎关注我" data-nolink="true" style="width: 100%; display: flex; justify-content: center;"><img src="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png" alt="欢迎关注我" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png" class="lozad post-image"></a></div></p>  </div>]]></content>
    
    
    <categories>
      
      <category>UML统一建模语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科普</tag>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础-目录 (Baidu AI Studio)</title>
    <link href="/2021/01/31/python%E5%9F%BA%E7%A1%80-%E7%9B%AE%E5%BD%95-%E7%99%BE%E5%BA%A6AI/"/>
    <url>/2021/01/31/python%E5%9F%BA%E7%A1%80-%E7%9B%AE%E5%BD%95-%E7%99%BE%E5%BA%A6AI/</url>
    
    <content type="html"><![CDATA[<p>本课一共有七个小节，最后一节是一个小测验，测试大家对Python的掌握情况~ 下面让我们来开始学习吧 ~</p><a id="more"></a><p class="note note-warning">    本文转载于Baidu AI Studio <br>    这篇课程详细清晰的讲解了python的基础语法，适合初学者，故记录于本博客</p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p><img src="https://ai-studio-static-online.cdn.bcebos.com/1a5d19a4b94241a9bd7b518e5417909361ee2f5b42fe4e5f98a53d4400b434e9"></p><p>在深度学习中，我们经常会看到很多demo是用Python来写的，Python也确实越来越火了，除了demo以外，目前主流的深度学习框架都支持Python，大家可以很方便的用Python来编程。在这一节课中我会教大家从基础的语法开始入手，学习Python的常用命令。本节课一共有七个小节，最后一节是一个小测验，测试大家对Python的掌握情况~ 下面让我们来开始学习吧 ~</p><h2 id="第一节-Python基础关键字和语法"><a href="#第一节-Python基础关键字和语法" class="headerlink" title="第一节 Python基础关键字和语法"></a>第一节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/98651">Python基础关键字和语法</a></h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>Hello World!</li><li>字符串操作</li><li>简单数学计算</li><li>if elif else</li><li>循环</li><li>小测试</li></ul><h2 id="第二节-Python中常见的数据结构"><a href="#第二节-Python中常见的数据结构" class="headerlink" title="第二节 Python中常见的数据结构"></a>第二节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/98653">Python中常见的数据结构</a></h2><h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><ul><li><p>字典</p><ul><li>访问字典种的值</li><li>更新字典</li><li>使用get()方法返回给定键的值</li><li>删除键同时也能返回值</li><li>遍历字典</li></ul></li><li><p>元组</p><ul><li><p>初始化</p></li><li><p>访问元组内的值</p></li><li><p>切分元组</p></li><li><p>元组方法</p><ul><li>index方法（索引）</li><li>count方法（计数）</li></ul></li><li><p>遍历元组</p></li><li><p>元组拆包</p></li><li><p>枚举</p></li><li><p>元组与列表的优劣分析</p></li></ul></li></ul><h2 id="第三节-Python中的for循环"><a href="#第三节-Python中的for循环" class="headerlink" title="第三节 Python中的for循环"></a>第三节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/98650">Python中的for循环</a></h2><h3 id="目录-2"><a href="#目录-2" class="headerlink" title="目录"></a>目录</h3><ul><li>枚举</li><li>Continue</li><li>Break</li></ul><h2 id="第四节-Python中的while循环"><a href="#第四节-Python中的while循环" class="headerlink" title="第四节 Python中的while循环"></a>第四节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/98649">Python中的while循环</a></h2><h3 id="目录-3"><a href="#目录-3" class="headerlink" title="目录"></a>目录</h3><ul><li>for循环与while循环区别</li><li>break语句</li></ul><h2 id="第五节-Python中的函数"><a href="#第五节-Python中的函数" class="headerlink" title="第五节 Python中的函数"></a>第五节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/98652">Python中的函数</a></h2><h3 id="目录-4"><a href="#目录-4" class="headerlink" title="目录"></a>目录</h3><ul><li><p>Python中的函数是什么？</p></li><li><p>创建函数的语法</p></li><li><p>如何在Python中调用函数</p></li><li><p>文档字符串</p></li><li><p>返回语句</p></li><li><p>变量的范围和寿命</p></li><li><p>参数</p></li><li><p>变量函数参数</p><ul><li>Python默认参数</li><li>Python关键字参数</li><li>Python任意参数</li></ul></li><li><p>在列表中重复对象</p></li></ul><h2 id="第六节-Python中的面向对象编程-本章节结合其他资料学习更易于理解"><a href="#第六节-Python中的面向对象编程-本章节结合其他资料学习更易于理解" class="headerlink" title="第六节 Python中的面向对象编程 (本章节结合其他资料学习更易于理解)"></a>第六节 <a href="https://aistudio.baidu.com/aistudio/projectDetail/100290">Python中的面向对象编程 (本章节结合其他资料学习更易于理解)</a></h2><h3 id="目录-5"><a href="#目录-5" class="headerlink" title="目录"></a>目录</h3><ul><li>Python类</li><li>对象实例</li><li>定义和使用方法</li><li>OOP继承</li></ul><h2 id="第七节让我们来做个小测验吧！"><a href="#第七节让我们来做个小测验吧！" class="headerlink" title="第七节让我们来做个小测验吧！"></a>第七节<a href="https://aistudio.baidu.com/aistudio/projectDetail/98654">让我们来做个小测验吧！</a></h2><h3 id="目录-6"><a href="#目录-6" class="headerlink" title="目录"></a>目录</h3><h4 id="常规测验"><a href="#常规测验" class="headerlink" title="常规测验"></a>常规测验</h4><ul><li>将字母转换成小写字母</li><li>反转字符串中的单词</li><li>排列组合</li><li>阶乘</li><li>整型转罗马数字</li><li>盛水最多的容器</li><li>矩阵置零</li><li>文件操作</li></ul><h4 id="高难度联系"><a href="#高难度联系" class="headerlink" title="高难度联系"></a>高难度联系</h4><ul><li>猜数字</li><li>FizzBuzz</li><li>猜数字的AI</li><li>整点报时</li><li>敏感词审查</li><li>文字毛线游戏</li><li>词频统计</li><li>Markdown转化器</li><li>邮件轰炸机</li><li>用邮件控制电脑</li></ul><hr><p>至此，Python从零入门的七个小节的课程已经全部学完了，你掌握了吗？</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是深度学习？</title>
    <link href="/2021/01/31/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9F/"/>
    <url>/2021/01/31/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p> 深度学习是一种机器学习方法 ， 它允许我们训练人工智能来预测输出，给定一组输入(指传入或传出计算机的信息)。监督学习和非监督学习都可以用来训练人工智能。</p><a id="more"></a><p class="note note-warning">本文转载于Baidu AI Studio</p><h1 id="什么是深度学习？"><a href="#什么是深度学习？" class="headerlink" title="什么是深度学习？"></a>什么是深度学习？</h1><p><img src="https://ai-studio-static-online.cdn.bcebos.com/60ba91a3d2c4427d82b933b25e490275e993d3e75f3149269a6d07efd3ff2067"></p><h1 id="一、深度学习的发展历程"><a href="#一、深度学习的发展历程" class="headerlink" title="一、深度学习的发展历程"></a>一、深度学习的发展历程</h1><h2 id="1-1-Turing-Testing-图灵测试"><a href="#1-1-Turing-Testing-图灵测试" class="headerlink" title="1.1 Turing Testing (图灵测试)"></a>1.1 Turing Testing (图灵测试)</h2><p>图灵测试是人工智能是否真正能够成功的一个标准，“计算机科学之父”、“人工智能之父”英国数学家图灵在1950年的论文《机器会思考吗》中提出了图灵测试的概念。即把一个人和一台计算机分别放在两个隔离的房间中，房间外的一个人同时询问人和计算机相同的问题，如果房间外的人无法分别哪个是人，哪个是计算机，就能够说明计算机具有人工智能。</p><h2 id="1-2-医学上的发现"><a href="#1-2-医学上的发现" class="headerlink" title="1.2 医学上的发现"></a>1.2 医学上的发现</h2><p>1981年的诺贝尔将颁发给了David Hubel和Torsten Wiesel，以及Roger Sperry。他们发现了<strong>人的视觉系统处理信息是分级的</strong>。 </p><p>从视网膜（Retina）出发，经过低级的V1区提取边缘特征，到V2区的基本形状或目标的局部，再到高层的整个目标（如判定为一张人脸），以及到更高层的PFC（前额叶皮层）进行分类判断等。也就是说<strong>高层的特征是低层特征的组合，从低层到高层的特征表达越来越抽象和概念化，也即越来越能表现语义或者意图</strong>。</p><blockquote><p>边缘特征 —–&gt; 基本形状和目标的局部特征——&gt;整个目标<br>这个过程其实和我们的常识是相吻合的，因为复杂的图形，往往就是由一些基本结构组合而成的。同时我们还可以看出：大脑是一个深度架构，认知过程也是深度的。</p></blockquote><p><img src="https://ai-studio-static-online.cdn.bcebos.com/14ba02554a4e48649332f4415341aab2cd94c6753c624265a16a8918498e6d2a"><br>人脑神经元示意图</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/8e35b368c84540bdbc29beaa2d78a29466801b7e43b146cda87087a117abce3a"><br>计算机识别图像的过程</p><h2 id="1-3-Deep-Learning的出现"><a href="#1-3-Deep-Learning的出现" class="headerlink" title="1.3 Deep Learning的出现"></a>1.3 Deep Learning的出现</h2><blockquote><p>低层次特征 - - - - (组合) - - -&gt;抽象的高层特征</p></blockquote><p>深度学习，恰恰就是通过组合低层特征形成更加抽象的高层特征（或属性类别）。例如，在计算机视觉领域，深度学习算法从原始图像去学习得到一个低层次表达，例如边缘检测器、小波滤波器等，然后在这些低层次表达的基础上，通过线性或者非线性组合，来获得一个高层次的表达。此外，不仅图像存在这个规律，声音也是类似的。比如，研究人员从某个声音库中通过算法自动发现了20种基本的声音结构，其余的声音都可以由这20种基本结构来合成！</p><h1 id="二、机器学习"><a href="#二、机器学习" class="headerlink" title="二、机器学习"></a>二、机器学习</h1><p>机器学习是实现人工智能的一种手段，也是目前被认为比较有效的实现人工智能的手段，目前在业界使用机器学习比较突出的领域很多，例如：计算机视觉、自然语言处理、推荐系统等等。大家生活中经常用到的比如高速上的ETC的车牌识别，今日头条的新闻推荐，天猫上的评价描述。<br>机器学习是人工智能的一个分支，而在很多时候，几乎成为人工智能的代名词。简单来说，机器学习就是通过算法，使得机器能从大量历史数据中学习规律，从而对新的样本做智能识别或对未来做预测。</p><h2 id="2-1-人工智能vs机器学习"><a href="#2-1-人工智能vs机器学习" class="headerlink" title="2.1 人工智能vs机器学习"></a>2.1 人工智能vs机器学习</h2><blockquote><p>人工智能是计算机科学的一个分支，研究计算机中智能行为的仿真。</p></blockquote><p>每当一台机器根据一组预先定义的解决问题的规则来完成任务时，这种行为就被称为人工智能。</p><p>开发人员引入了大量计算机需要遵守的规则。计算机内部存在一个可能行为的具体清单，它会根据这个清单做出决定。如今，人工智能是一个概括性术语，涵盖了从高级算法到实际机器人的所有内容。</p><p>我们有四个不同层次的AI，让我们来解释前两个:</p><ul><li>弱人工智能，也被称为狭义人工智能，是一种为特定的任务而设计和训练的人工智能系统。弱人工智能的形式之一是虚拟个人助理，比如苹果公司的Siri。</li><li>强人工智能，又称人工通用智能，是一种具有人类普遍认知能力的人工智能系统。当计算机遇到不熟悉的任务时，它具有足够的智能去寻找解决方案。</li></ul><p>机器学习是指计算机使用大数据集而不是硬编码规则来学习的能力。</p><p>机器学习允许计算机自己学习。这种学习方式利用了现代计算机的处理能力，可以轻松地处理大型数据集。</p><p>基本上，机器学习是人工智能的一个子集;更为具体地说，它只是一种实现AI的技术，一种训练算法的模型，这种算法使得计算机能够学习如何做出决策。</p><p>从某种意义上来说，机器学习程序根据计算机所接触的数据来进行自我调整。</p><h2 id="2-2-监督式学习vs非监督式学习"><a href="#2-2-监督式学习vs非监督式学习" class="headerlink" title="2.2 监督式学习vs非监督式学习"></a>2.2 监督式学习vs非监督式学习</h2><blockquote><p>监督式学习需要使用有输入和预期输出标记的数据集。</p></blockquote><p>当你使用监督式学习训练人工智能时，你需要提供一个输入并告诉它预期的输出结果。</p><p>如果人工智能产生的输出结果是错误的，它将重新调整自己的计算。这个过程将在数据集上不断迭代地完成，直到AI不再出错。</p><p>监督式学习的一个例子是天气预报人工智能。它学会利用历史数据来预测天气。训练数据包含输入(过去天气的压力、湿度、风速)和输出(过去天气的温度)。</p><p>我们还可以想象您正在提供一个带有标记数据的计算机程序。例如，如果指定的任务是使用一种图像分类算法对男孩和女孩的图像进行分类，那么男孩的图像需要带有“男孩”标签，女孩的图像需要带有“女孩”标签。这些数据被认为是一个“训练”数据集，直到程序能够以可接受的速率成功地对图像进行分类，以上的标签才会失去作用。</p><p>它之所以被称为监督式学习，是因为算法从训练数据集学习的过程就像是一位老师正在监督学习。在我们预先知道正确的分类答案的情况下，算法对训练数据不断进行迭代预测，然后预测结果由“老师”进行不断修正。当算法达到可接受的性能水平时，学习过程才会停止。</p><blockquote><p>非监督式学习是利用既不分类也不标记的信息进行机器学习，并允许算法在没有指导的情况下对这些信息进行操作。</p></blockquote><p>当你使用非监督式学习训练人工智能时，你可以让人工智能对数据进行逻辑分类。这里机器的任务是根据相似性、模式和差异性对未排序的信息进行分组，而不需要事先对数据进行处理。</p><p>非监督式学习的一个例子是亚马逊等电子商务网站的行为预测AI。</p><p>它将创建自己输入数据的分类，帮助亚马逊识别哪种用户最有可能购买不同的产品(交叉销售策略)。<br>另一个例子是，程序可以任意地使用以下两种算法中的一种来完成男孩女孩的图像分类任务。一种算法被称为“聚类”，它根据诸如头发长度、下巴大小、眼睛位置等特征将相似的对象分到同一个组。另一种算法被称为“相关”，它根据自己发现的相似性创建if/then规则。换句话说，它确定了图像之间的公共模式，并相应地对它们进行分类。</p><h1 id="三、深度学习如何工作"><a href="#三、深度学习如何工作" class="headerlink" title="三、深度学习如何工作"></a>三、深度学习如何工作</h1><p>什么是深度学习，以及它是如何工作的。</p><p>深度学习是一种机器学习方法 ， 它允许我们训练人工智能来预测输出，给定一组输入(指传入或传出计算机的信息)。监督学习和非监督学习都可以用来训练人工智能。</p><blockquote><p>Andrew Ng：“与深度学习类似的是，火箭发动机是深度学习模型，燃料是我们可以提供给这些算法的海量数据。”</p></blockquote><p>我们将通过建立一个公交票价估算在线服务来了解深度学习是如何工作的。为了训练它，我们将使用监督学习方法。</p><p>我们希望我们的巴士票价估价师使用以下信息/输入来预测价格:<br><img src="https://ai-studio-static-online.cdn.bcebos.com/8dfb449f950f479789c91dbe580367cb0c911078e61a45c0a45cb7fd402cfb9e"></p><h2 id="3-1-神经网络"><a href="#3-1-神经网络" class="headerlink" title="3.1 神经网络"></a>3.1 神经网络</h2><p>神经网络是一组粗略模仿人类大脑，用于模式识别的算法。神经网络这个术语来源于这些系统架构设计背后的灵感，这些系统是用于模拟生物大脑自身神经网络的基本结构，以便计算机能够执行特定的任务。 </p><p>和人类一样， “AI价格评估”也是由神经元(圆圈)组成的。此外，这些神经元还是相互连接的。 </p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/24ba46820718419da5b164c55410fa871bc1dc870377440894dae3a77b85957d"></p><p>神经元分为三种不同类型的层次：</p><ul><li><p>输入层接收输入数据。在我们的例子中，输入层有四个神经元:出发站、目的地站、出发日期和巴士公司。输入层会将输入数据传递给第一个隐藏层。</p></li><li><p>隐藏层对输入数据进行数学计算。创建神经网络的挑战之一是决定隐藏层的数量，以及每一层中的神经元的数量。</p></li><li><p>人工神经网络的输出层是神经元的最后一层，主要作用是为此程序产生给定的输出，在本例中输出结果是预测的价格值。</p></li></ul><p><img src="https://ai-studio-static-online.cdn.bcebos.com/5f0617e162a145ebafc97631534484a1e68e44b4b2374c299b06ed995ccc8c3b"></p><p>神经元之间的每个连接都有一个权重。这个权重表示输入值的重要性。模型所做的就是学习每个元素对价格的贡献有多少。这些“贡献”是模型中的权重。一个特征的权重越高，说明该特征比其他特征更为重要。</p><p>在预测公交票价时，出发日期是影响最终票价的最为重要的因素之一。因此，出发日期的神经元连接具有较大的“权重”。</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/45ec203def6145c7948481834b56a34fcca2ea9a52a64397971b04ac43b87a92"></p><p>每个神经元都有一个激活函数。它主要是一个根据输入传递输出的函数。<br>当一组输入数据通过神经网络中的所有层时，最终通过输出层返回输出数据。</p><h2 id="3-2-通过训练改进神经网络"><a href="#3-2-通过训练改进神经网络" class="headerlink" title="3.2 通过训练改进神经网络"></a>3.2 通过训练改进神经网络</h2><p>为了提高“AI价格评估”的精度，我们需要将其预测结果与过去的结果进行比较，为此，我们需要两个要素:</p><ul><li>大量的计算能力；</li><li>大量的数据。</li></ul><p>训练AI的过程中，重要的是给它的输入数据集(一个数据集是一个单独地或组合地或作为一个整体被访问的数据集合),此外还需要对其输出结果与数据集中的输出结果进行对比。因为AI一直是“新的”，它的输出结果有可能是错误的。</p><p>对于我们的公交票价模型，我们必须找到过去票价的历史数据。由于有大量“公交车站”和“出发日期”的可能组合，因而我们需要一个非常大的票价清单。</p><p>一旦我们遍历了整个数据集，就有可能创建一个函数来衡量AI输出与实际输出(历史数据)之间的差异。这个函数叫做成本函数。即成本函数是一个衡量模型准确率的指标，衡量依据为此模型估计X与Y间关系的能力。</p><p>模型训练的目标是使成本函数等于零，即当AI的输出结果与数据集的输出结果一致时（成本函数等于0）。</p><h2 id="3-3-我们如何降低成本函数呢"><a href="#3-3-我们如何降低成本函数呢" class="headerlink" title="3.3 我们如何降低成本函数呢?"></a>3.3 我们如何降低成本函数呢?</h2><p>通过使用一种叫做梯度下降的方法。梯度衡量得是，如果你稍微改变一下输入值，函数的输出值会发生多大的变化。</p><p>梯度下降法是一种求函数最小值的方法。在这种情况下，目标是取得成本函数的最小值。<br>它通过每次数据集迭代之后优化模型的权重来训练模型。通过计算某一权重集下代价函数的梯度，可以看出最小值的梯度方向。</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/666c7aca1f69433490eb0a183e0b8dc7d79e9541f6d54d1985e3eba67f322c1d"></p><p>为了降低成本函数值，多次遍历数据集非常重要。这就是为什么需要大量计算能力的原因。<br>一旦我们通过训练改进了AI，我们就可以利用它根据上述四个要素来预测未来的价格。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习与神经网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>自然语言处理</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo多部署-同时部署到阿里云OSS和Github</title>
    <link href="/2021/01/31/Hexo%E5%A4%9A%E9%83%A8%E7%BD%B2-%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%92%8CGithub/"/>
    <url>/2021/01/31/Hexo%E5%A4%9A%E9%83%A8%E7%BD%B2-%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%92%8CGithub/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo多部署-同时部署到阿里云OSS和Github"><a href="#Hexo多部署-同时部署到阿里云OSS和Github" class="headerlink" title="Hexo多部署-同时部署到阿里云OSS和Github"></a>Hexo多部署-同时部署到阿里云OSS和Github</h1><a id="more"></a><style>img {    display: block;    margin: 0 auto;}</style><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文基于<a href="https://6ss.top/posts/20200902/">1元 高速访问 博客网站 搭建方案</a> · <a href="https://www.uu126.cn/post/one-click-deployment-of-hexo-to-alibaba-cloud-oss.html">Hexo一键部署到阿里云OSS</a>进行补充，感谢原作分享</p><p>由于GitHub Page国内被限制，用服务器搭建静态博客的话相对成本较高，然后在酷安看到用阿里云对象存储OSS低成本搭建静态博客的帖子，于是着手尝试，成本总计2.99元    [1元(域名)+1.99元(服务号)]  (第一年)</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><strong>选择购买域名并备案</strong> (<a href="https://wanwang.aliyun.com/domain/1yuan">阿里云域名1元购</a>)<br>  （域名实名有两天左右的延迟才能备案,备案服务号可以淘宝解决）  <img src="https://img.imgdb.cn/item/601669f23ffa7d37b34887c9.jpg" width="300"></li></ul><br><ul><li><p><strong>开通阿里云对象存储OSS</strong> (<a href="https://www.aliyun.com/product/oss?spm=5176.119692.725171.40.6b101636SQQTS4">对象存储 OSS</a>)</p><p>  (默认为按量收费)    </p></li></ul><img src="https://img.imgdb.cn/item/60166f3d3ffa7d37b34a88ab.jpg"><br><ul><li><strong>完成各种实名认证和信息登记</strong></li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="创建Bucket"><a href="#创建Bucket" class="headerlink" title="创建Bucket"></a>创建Bucket</h3><p>需要创建一个公共读的Bucket，用以设置静态网站托管及存放网站数据。</p><ul><li><p>登录OSS管理控制台。</p></li><li><p>单击Bucket列表，然后单击创建Bucket。</p></li><li><p>在创建Bucket面板配置Bucket参数，其中：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Bucket名称</td><td>设置Bucket名称。</td></tr><tr><td>地域</td><td>选择Bucket所在地域。</td></tr><tr><td>存储类型</td><td>选择标准存储。</td></tr><tr><td>读写权限</td><td>选择公共读。</td></tr></tbody></table></li><li><p>进入创建好的Bucket，点击基础设置，设置静态页面的默认首页为 index.html</p></li></ul><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><h3 id="设置AccessKey"><a href="#设置AccessKey" class="headerlink" title="设置AccessKey"></a>设置AccessKey</h3><ul><li><p><strong>在网页右上角点击AccessKey管理</strong></p><img src="https://img.imgdb.cn/item/601676893ffa7d37b34d4281.jpg"></li><li><p><strong>创建子用户然后添加权限</strong></p><ul><li>创建子用户<img src="https://img.imgdb.cn/item/601678e33ffa7d37b34e1bb7.jpg"></li><li>勾选编程访问<img src="https://img.imgdb.cn/item/601678fe3ffa7d37b34e2832.jpg"></li><li>添加权限<img src="https://img.imgdb.cn/item/601677473ffa7d37b34d8252.jpg"></li></ul></li></ul><ul><li><strong>选择管理对象存储服务(OSS)权限</strong>  <img src="https://img.imgdb.cn/item/601677d03ffa7d37b34dab91.jpg"></li></ul><ul><li><strong>进入用户，创建AccessKey</strong> <img src="https://img.imgdb.cn/item/601678a63ffa7d37b34dff70.jpg"> <p class="note note-warning">复制生成好的AccessKey ID 和 AccessKey Secret</p></li></ul><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><ul><li><p><strong>在hexo的目录下执行：</strong></p><pre><code>  npm install hexo-deployer-ali-oss --save</code></pre></li><li><p><strong>在hexo_config.yml文件中部署配置</strong></p></li></ul><p class="note note-warning">单部署器</p><pre><code>    deploy:    type: ali-oss    region: &lt;您的oss 区域代码&gt;    accessKeyId: &lt;您的oss  accessKeyId&gt;    accessKeySecret: &lt;您的oss accessKeySecret&gt;    bucket: &lt;您的bucket name&gt;</code></pre><p class="note note-warning">多部署器</p><img src="https://img.imgdb.cn/item/60167c6e3ffa7d37b34f5acc.jpg"><br><ul><li><a href="https://hexo.io/docs/one-command-deployment">hexo官方文档对部署器配置的解释</a></li></ul><h2 id="完成部署"><a href="#完成部署" class="headerlink" title="完成部署"></a>完成部署</h2><p>全部部署完成后，即可通过 hexo g 将博客同时推送至OSS和Github</p>]]></content>
    
    
    <categories>
      
      <category>hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客部署</tag>
      
      <tag>对象存储OSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视频编码</title>
    <link href="/2021/01/30/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"/>
    <url>/2021/01/30/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>如今我们所处的时代，是移动互联网时代，也可以说是视频时代。我们的生活被越来越多的视频元素所影响，而这一切，离不开视频拍摄技术的不断升级，还有视频制作产业的日益强大。除了视频拍摄工具和网络通信技术升级之外，我们能享受到视<br>频带来的便利和乐趣，还有一个重要因素，就是视频编码技术的突飞猛进。本文将对视频编码技术基础进行简述</p><a id="more"></a><h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><h3 id="视频压缩"><a href="#视频压缩" class="headerlink" title="视频压缩"></a>视频压缩</h3><hr><ul><li><strong>压缩</strong><ul><li><strong>为什么要压缩？</strong><ul><li>未经压缩的数字视频的数据量<strong>巨大</strong></li><li>存储困难</li><li>传输困难</li></ul></li></ul></li></ul><!--more--><ul><li><p><strong>为什么可以压缩？</strong></p><ul><li><p>去除冗余信息</p><ul><li><p>空间冗余: 图像相邻像素之间有较强的相关性</p></li><li><p>时间冗余: 视频序列的相邻图像之间内容相似</p></li><li><p>编码冗余: 不同像素值出现的概率不同</p></li><li><p>视觉冗余: 人的视觉系统对某些细节不敏感</p></li><li><p>知识冗余: 规律性的结构可由先验知识和背景知识得到</p><pre><code>   针对这些不同类型的冗余信息，在各种视频编码的标准算法中都有不同的技术专门应对，   以通过不同的角度提高压缩的比率。</code></pre></li></ul></li></ul></li><li><p><strong>数据压缩分类</strong></p><ul><li><p>无损压缩(Lossless)</p><ul><li>压缩前解压缩后图像完全一致 <strong>X=X’</strong></li><li>压缩比低(2:1~3:1)</li><li>例如: <ul><li>JPEG-LS(一种对连续色调图像的无损或者近无损的压缩标准)</li><li>Winzip</li></ul></li></ul></li><li><p>有损压缩(Lossy)</p><ul><li><p>压缩前解压缩后图像不一致 <strong>X≠X’</strong></p></li><li><p>压缩比高(10:1~20:1)</p></li><li><p>利用人的视觉系统的特性</p></li><li><p>例如:MPEG-2，H.264/AVC，AVS</p><p>   <strong>AVS与MPEG-2、MPEG-4 AVC/H.264使用的技术对比和性能差异估计</strong></p></li></ul></li></ul></li></ul><img src="https://img.imgdb.cn/item/601572f43ffa7d37b3f64e77.jpg"><!-- |视频编码标准|MPEG-2视频|MPEG-4 AVC/H.264视频|AVS视频|AVS视频与AVC/H.264性能差异估计（采用信噪比dB估算,括号内的百分比为码率差异）||--|--|--|--|--|--|--|--|--||帧内预测|只在频域内进行DC系数差分预测|基于4×4块，9种亮度预测模式，4种色度预测模式|基于8×8块，5种亮度预测模式，4种色度预测模式|基本相当||多参考帧预测|只有1帧|最多16帧|最多2帧|都采用两帧时相当，帧数增加性能提高不明显||变块大小运动补偿|16×16，16×8(场编码)|16×16、16×8、8×16、8×8、8×4、4×8、4×4|16×16、16×8、8×16、8×8|降低约0.1dB(2-4%)||B帧宏块直接编码模式|无|独立的空域或时域预测模式，若后向参考帧中用于导出运动矢量的块为帧内编码时，只是视其运动矢量为0，依然用于预测|时域空域相结合，当时域内后向参考帧中用于导出运动矢量的块为帧内编码时，使用空域相邻块的运动矢量进行预测|提高0.2-0.3dB(5%)||B帧宏块双向预测模式|编码前后两个运动矢量|编码前后两个运动矢量|称为对称预测模式，只编码一个前向运动矢量，后向运动矢量由前向导出|基本相当||熵编码|单一VLC表，适应性差|CAVLC：与周围块相关性高，实现较复杂CABAC：计算较复杂|上下文自适应2D-VLC，编码块系数过程中进行多码表切换|降低约0.5dB(10-15%)||环路滤波|无|基于4×4块边缘进行，滤波强度分类繁多，计算复杂|基于8×8块边缘进行，简单的滤波强度分类，滤波较少的像素，计算复杂度低|——||容错编码|简单的条带划分|数据分割、复杂的FMO/ASO等宏块、条带组织机制、强制Intra块刷新编码、约束性帧内预测等|简单的条带划分机制足以满足广播应用中的错误隐藏、恢复需求|——| --><pre><code>DCT（Discrete Cosine Transform）：离散余弦变换VLC（Variable Length Coding）：变长编码CAVLC（Context-based Adaptive Variable Length Coding）：基于上下文的自适应变长码CABAC（Context-based Adaptive Binary Arithmetic Coding）：基于上下文的自适应二进制算术编码FMO（Flexible Macroblock Ordering）：灵活的宏块排序ASO（Arbitrary Slice Ordering）：任意条带排列</code></pre><br><h3 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h3><hr><p class="note note-info">    数字视频有时间分辨率、空间分辨率、色彩空间、量化深度等参数，这些参数的组合称为视频格式</p><ul><li><p><strong>时间</strong>——帧率（frame per second）——流畅</p></li><li><p><strong>空间</strong>——分辨率——清晰</p></li><li><p><strong>色彩空间</strong></p><ul><li><p><strong>RGB颜色空间</strong></p>   <p class="note note-danger">                   RGB（红绿蓝）是依据人眼识别的颜色定义出的空间，可表示大部分颜色。       但在科学研究一般不采用RGB颜色空间，因为它的细节难以进行数字化的调整。       它将色调，亮度，饱和度三个量放在一起表示，很难分开。       它是最通用的面向硬件的彩色模型。该模型用于彩色监视器和一大类彩色视频摄像。   </p></li><li><p><strong>YUV颜色空间</strong></p>   <p class="note note-success">           在 YUV空间中，每一个颜色有一个亮度信号 Y，和两个色度信号 U 和V。       亮度信号是强度的感觉，它和色度信号断开，这样的话强度就可以在不影响颜色的情况下改变。       视频通信系统之所以要采用YUV，而不是RGB，主要是因为RGB信号不利于压缩。       在YUV这种方式里面，加入了亮度这一概念。眼睛对于亮和暗的分辨要比对颜色的分辨更精细一些，       人眼对色度的敏感程度要低于对亮度的敏感程度。   </p>　　所以，工程师认为，在我们的视频存储中，没有必要存储全部颜色信号。我们可以把更多带宽留给黑—白信号(被称作“亮度”)，将稍少的带宽留给彩色信号(被称作“色度”)。于是，就有了YUV。YUV里面的“Y”，就是亮度(Luma)，“U”和“V”则是色度(Chroma)</li><li><p><strong>YCbCr颜色空间</strong></p></li></ul></li></ul><p class="note note-secondary">            YCbCr 是在世界数字组织视频标准研制过程中作为ITU-RBT1601建议的一部分,其实是YUV经过缩放和偏移的翻版。            其中Y与YUV中的Y含义一致,Cb,Cr同样都指色彩, 只是在表示方法上不同而已。            在YUV家族中,YCbCr是在计算机系统中应用最多的成员,其应用领域很广泛,             JPEG、MPEG均采用此格式。</p><p><strong>Y表示亮度，CbCr表示颜色。怎么表示颜色，可以看下面这幅坐标图</strong></p><img style="display: block; margin: 0 auto;" src="https://img.imgdb.cn/item/60156cbf3ffa7d37b3f3238a.png" width = "300" height = "300"  /><p><strong>Y要如何表示亮度呢，下面是Y在不同的情况下的表现</strong></p><img style="display: block; margin: 0 auto;" src="https://img.imgdb.cn/item/60156ccf3ffa7d37b3f32a3e.png" width = "600" height = "200"  /><br><ul><li><p><strong>存储方式</strong></p><p> <strong>以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量</strong></p></li></ul><img style="display: block; margin: 0 auto;" src="https://img.imgdb.cn/item/60156cdd3ffa7d37b3f32f33.jpg" width = "660" height = "200"  /><ul><li><p>YUV 4:4:4采样，每一个Y对应一组UV分量。</p></li><li><p>YUV 4:2:2采样，每两个Y共用一组UV分量。</p></li><li><p>YUV 4:2:0采样，每四个Y共用一组UV分量。</p><br></li><li><p><strong>量化深度</strong>——精确</p><pre><code> 像素每一分量的数值对应的量化等级为量化深度，量化深度越大，像素值可以越精确。 8 bit 10bit</code></pre><ul><li><p>10bit的视频记录更精确的色彩，比如我们平时用的rgb 每个通道8bit，那么每个颜色分量就0~255，只有256个，而10bit就有1024个。实际体验上，更细致的颜色分级意味着渐变色更细腻</p><pre><code>  视频的10bit的压制。  可以在保持高画质的前提下大大提升压缩效率，10bit压制主要是通过提升编码的精度，  从而在有损压缩时可以采用更高的量化值，同时保持十分好的质量，  于是可以在比8bit压制更低的码率下还原出更好的画面。  10bit在更高的精度冗余下可以在有损编码时有更高的效率。  具体对于画质有利的方面主要在于：  1.防止banding（色彩平滑过渡区域的色带）产生  2 提升暗场效果  3.更好地容纳噪点  而这几项正好都是现在8bit压制中很难处理的地方。特别是对于动画，  banding是个及其麻烦的东西。暗场是十分容易码率分配不足，并且产生画面劣化的部分。  而噪点则是十分消耗码率。10bit下这些困难的东西都变得容易处理了。  目前所使用的10bit压制是作用于内部的编码精度，而不是输出精度。</code></pre></li></ul></li></ul><h2 id="视频编码原理"><a href="#视频编码原理" class="headerlink" title="视频编码原理"></a>视频编码原理</h2><ul><li>冗余编码技术</li><li><img style="display: block; margin: 0 auto;" src="https://www.easemob.com/data/upload/ueditor/20191121/5dd62e0bd14a3.jpg"><br></li></ul><img style="display: block; margin: 0 auto;" src="https://www.easemob.com/data/upload/ueditor/20191121/5dd62e0c0cb08.jpg"><p>视频编码技术优先消除的目标，就是空间冗余和时间冗余。<br><br></p><ul><li>视频是由不同的帧画面连续播放形成的。这些帧，主要分为三类，分别是：<ul><li><strong>I帧</strong>：是自带全部信息的独立帧，是最完整的画面(占用的空间最大)，无需参考其它图像便可独立进行解码。视频序列中的第一个帧，始终都是I帧。<br></li><li><strong>B帧</strong>：“双向预测编码帧”，以前帧后帧作为参考帧。不仅参考前面，还参考后面的帧，所以，它的压缩率最高，可以达到200:1。不过，因为依赖后面的帧，所以不适合实时传输(例如视频会议)。<img style="display: block; margin: 0 auto;" src="https://www.easemob.com/data/upload/ueditor/20191121/5dd62e0cb81b8.jpg"><br></li><li><strong>P帧</strong>：“帧间预测编码帧”，需要参考前面的I帧和/或P帧的不同部分，才能进行编码。P帧对前面的P和I参考帧有依赖性。但是，P帧压缩率比较高，占用的空间较小。<img style="display: block; margin: 0 auto;" src="https://www.easemob.com/data/upload/ueditor/20191121/5dd62e0c74ff8.jpg"><br></li></ul></li></ul><p class="note note-primary">时间冗余（帧间预测）</p><p class="note note-primary">空间冗余（帧内预测）</p><br><h2 id="视频数据的封装"><a href="#视频数据的封装" class="headerlink" title="视频数据的封装"></a>视频数据的封装</h2><pre><code>　　对于任何一部视频来说，只有图像，没有声音，肯定是不行的。所以，视频编码后，加上音频编码，要一起进行封装。　　封装：就是封装格式，简单来说，就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中。    再通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个饭盒，用来盛放饭菜的容器。　　目前主要的视频容器有如下：MPG、VOB、MP4、3GP、ASF、RMVB、WMV、MOV、Divx、MKV、FLV、TS/PS等。　　封装之后的视频，就可以传输了，你也可以通过视频播放器进行解码观看。</code></pre><p>　</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p class="note note-info">     <a href="https://blog.csdn.net/asahinokawa/article/details/80596655">[1] 对颜色空间 YUV,RGB 的理解</a><br>    <a href="https://www.easemob.com/news/3614">[2] 视频编码技术详解</a><br>    <a href="https://blog.csdn.net/SYB773849846/article/details/51789994">[3] RGB,YUV,YCbCr 几种颜色空间的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>音视频</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频编码</tag>
      
      <tag>科普</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/21/hello-world/"/>
    <url>/2021/01/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
